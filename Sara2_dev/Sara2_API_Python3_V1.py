# create the class for holding all the data associated with each design. 
# use namedtuple for memory for for what is parsed from spreedsheets and 
# fold data generated by nupack as should not change
from decimal import Decimal
import string
from tokenize import Double
from turtle import st
from typing import Dict, NamedTuple, List, Optional
from unicodedata import decimal
import pandas as pd
import sys
import openpyxl
from dataclasses import dataclass, field
#import mysql.connector
#from mysql.connector import Error
import pandas as pd
from collections import OrderedDict
from enum import Enum


import nupackAPI_Sara2_Ver1 as nupackAPI


#this is the stuff that is generated by Rhijus wet lab
class WetlabData(object):
    Sequence: str = ""
    Eterna_Score: float = -1
    Baseline_Subscore: float = -1
    Folding_Subscore: float = -1
    Switch_Subscore: float = -1
    NumberOfClusters1: int = -1
    FoldChange: float = -1
    FoldChange_err_factor: float = -1
    KDOFF: float = -1
    KDON: float = -1
    ddG: float = -1
    ddG_err: float = -1

#data commonly associated with secondary structures. written with alternate structures in mind
#class structureData(NamedTuple):
#    secondaryStructure: str
#    freeEnergy: float
#    deltaMfeEnergy: float  

#this is the data the generated by folding software and in this case it is nupack
class NupackFoldData(object):
    temperature: int = -1
    doPknot: bool = False
    isPknot: bool = False
    #mfeInfo: structureData
    #alternateStructureList: List[structureData]
    pairprobsList: List[List[float]] = [[]]
    #primaryPairsList:list
    #primaryPairsSortedList: list
    #secondaryPairsList: list
    #secondaryPairsSortedList: list
    #_allocations: set = field(default_factory=set)

#class Oligos(NamedTuple):
#    oligoSequence: str
#    oligoSequenceLenght:str
#    OligoConcentration: str


class DesignInformation(object):
    Sequence: str = ''
    Sequence_Length: int = -1
    #oligosList: List[Oligos]
    DesignID: int = -1
    Design: str =''
    Player: str = ''
    Puzzle_Name: str =''
    Sublab_ID: int = -1
    Sublab_Name: str = ''
    Puzzle_Name: str = ''
    Puzzle_ID: int -1


#entry point for each design in a puzzle/lab
class DesignPerformanceData:    
    DesignInfo: DesignInformation = None
    wetlabResults: WetlabData = None
    nupackFoldResults: NupackFoldData = None

#entry point to puzzle or lab as we call them
#@dataclass
class puzzleData(object):
    Puzzle_Name: str = ''
    Puzzle_ID: int -1
    designsList: List[DesignPerformanceData] =[]
    designsDict: Dict[str, DesignPerformanceData] ={}


#class RoundData(NamedTuple):
#    roundName: str
#    roundID: int
#    puzzleLabList: List[puzzleData]

       

class Sara2:
    # for each design entry we make a DesignData object and add that to a Lst once that is done 
    # we add it to a puzzleData object and once that is done for all the puzzles we then add it to a round data and wea re finished.
    # I think round data should be changable

    def __init__(self) -> None:
        self.something ="31415"

    def GetNamesClass(self, className):
        variables = [i for i in vars(className).keys() if not callable(i) and not i.startswith('__') ]
        #variables = list(vars(className).keys())
        return variables

    def openExcelWetlab(self, path, designRoundSheet):
        #$designRound = "Round 7 (R101)"
        pnasPath = r'pnas.2112979119.sd01.xlsx'
        designRound = "Round 7 (R101)"
        roundData = ['DesignID', 'Design', 'Player', 'Puzzle_Name', 'Eterna_Score', 'FoldChange', 'Sequence']
        sheet = pd.read_excel(path, sheet_name=designRoundSheet).itertuples()
        return sheet

    def GenerateNupackEntry(self, wetlabDataObject: WetlabData, temperature, doPknot):
        #now need to run each design through nupack
        #pairProbsList = List[List[float]]
        pairProbsList = nupackAPI.GetPairProbs2DArray(wetlabDataObject.Sequence, 'rna95-nupack3', temperature)
        
        isPknot=False
        if doPknot is False:
            isPknot=False
        else:
            doPknot=True
        
        nupackEntry = NupackFoldData()
        nupackEntry.temperature = temperature
        nupackEntry.doPknot = doPknot
        nupackEntry.isPknot = isPknot
        nupackEntry.pairprobsList = pairProbsList       
        
        #(temperature=temperature, doPknot=doPknot, isPknot=isPknot, pairprobsList=pairProbsList)
        return nupackEntry

    def GetSetValue(self, getObject, variableSeek, setObject):
        value = getattr(getObject, variableSeek)
        setattr(setObject, variableSeek, value)
        return setObject

    def GenerateWetlabEntry(self, row: NamedTuple):
        wetlab = WetlabData()
        #this is a list of the variable names from the wetlab class
        variables = self.GetNamesClass(WetlabData)
        for variable in variables:
            #sourceValue = getattr(row, variable)
            #setattr(wetlab, variable, sourceValue)
            wetlab =  self.GetSetValue(row, variable, wetlab)
        #for name, value in WetlabData.__dict__().items():
        #    wetlab =  GetSetValue(row, name, wetlab)
        #all the contents of the wetlab excel should now be loaded into wetlabData object wetlab
        #return it then
        return wetlab


    def GenerateDesignInfo(self, row: NamedTuple):
        designInfo = DesignInformation()
        #this is a list of the variable names from the wetlab class
        members = self.GetNamesClass(DesignInformation)
        for variable in members:
            self.GetSetValue(row, variable, designInfo)
        return designInfo
        

    def ProcessLab(self, path, designRound_sheet):
        sheet = self.openExcelWetlab(path, designRound_sheet)
        #first do the Design entry stuff  

        designs: List[DesignPerformanceData] = []
        designsDict: Dict[str, DesignInformation] = {}
        
        for row in sheet:
            wetlabResults: WetlabData
            nupackRestuls: NupackFoldData
            desingInfo: DesignInformation
            # this is a single line from teh file and representas a single design. load this into wetlabdata
            # and then do nupack. each row is in a namedtouple formate
            desingInfo = self.GenerateDesignInfo(row)
            designName = desingInfo.Design
            designID = desingInfo.DesignID
            desingString:str = f'Processing DesingID={designID}, DesignName={designName}'
            print(desingString)
            wetlabResults = self.GenerateWetlabEntry(row)
            nupackRestuls = self.GenerateNupackEntry(wetlabResults, 37, False)
            DesingData = DesignPerformanceData()
            DesingData.DesignInfo = desingInfo
            DesingData.wetlabResults = wetlabResults
            DesingData.nupackFoldResults = nupackRestuls            
            #(DesignInfo=desingInfo, wetlabResults=wetlabResults, nupackFoldResults=nupackRestuls)
            designs.append(DesingData)
            designsDict[DesingData.DesignInfo.DesignID]=DesingData

        #need to change this to account for sublabs



        puzzlename = designs[0].DesignInfo.Puzzle_Name
        #lets stop at puzzle data until this is fully gigure out and tested a bit
        puzzleInfo = puzzleData()
        puzzleInfo.Puzzle_Name=puzzlename
        puzzleInfo.designsList=designs
        puzzleInfo.designsDict=designsDict
        #(Puzzle_Name=puzzlename, designsList=designs, designsDict=designsDict)    
        return puzzleInfo



    #this will give a list of pairs based on prob level
    def NucProbSearch(self, foldData: NupackFoldData, probThresh):
        pairsList = foldData.pairprobsList
        snuppPairsDict= dict(string, float)
        snuppList = []

        for i in range(len(pairsList)):        
            for j in range(len(pairsList[i])):
                pairValue = pairsList[i][j]
                if pairValue >= probThresh:
                    #pair = NucPair(i,j)
                    pairName = "{i}:{j}".format(i=i, j=j)
                    snuppPairsDict[pairName]=pairValue
                    snuppList.append(pairName)
        return snuppPairsDict, snuppList     
    #this is new stuff to do snupp pairs like it should have been in the C# code.

    #need to add a function for EV and this can be used to guide me on the Eterna EV stuff
